#! /usr/bin/env python3
# encoding: utf-8

# This script is taylor made for the bundles of exercises generated by
# Moodle 2.
#
# TODO:
#   1. allow configuring the repository of downloaded bundles as a
#   different folder from the destination of the extracted contents
#   2. Allow for confirmation and improve warnings (maybe logging)
#   3. some refactor would be nice! This is poor code and you now it!

import os, re
import zipfile
import tempfile, shutil
import json
import subprocess

_MOODLE_FILE_TEMPL = "(.*?)-(.*?)-(\d+)\.zip$"
_SUBMISSION_TEMPL  = "(.*?)_(.*?)_assignsubmission_file_(.*)"
_VALID_CHARS       = "[^a-zA-Z0-9]+"
_REPLACE_CHAR      = "_"


# External file with mapping between expected students and its folders
# This map just eases folder naming
_EXTERNAL_CONFIGURATION_FILE = os.path.abspath("./ies_extract_params.json")
if os.path.isfile(_EXTERNAL_CONFIGURATION_FILE):
    with open(_EXTERNAL_CONFIGURATION_FILE) as f:
        _STUDENT_NAME_CONVERSION = json.loads(f.read())
else:
    _STUDENT_NAME_CONVERSION = dict()


# Commands for uncompressing files { mime-type: command }
_UNCOMPRESS_COMMAND = {
    "x-7z-compressed" : "p7zip -d '%s'",
    "gzip" : "tar xzvf '%s'",
    "x-tar" : "tar xvf '%s'",
    "x-rar" : "unrar x '%s'",
    "zip" : "jar xvf '%s'",
    "java-archive" : "jar xvf '%s'",
}

# regex to extract app type from mimetype
_MIMETYPE_EXPR='^.* application\\/(.*);.*$'

def getCompressCommand(path):
    """ returns the command to be issued for uncompressing the file.
    If the filetype is unknown, none is return instead """
    mimetype = subprocess.Popen("/usr/bin/file --mime '%s'"%path, shell=True, stdout=subprocess.PIPE).communicate()[0]
    l = re.findall(_MIMETYPE_EXPR, mimetype)
    command = None
    if len(l) < 1:
        return None
    if len(l) > 1:
        print("WARNING: more than one type for file %s (%s)"%(path, l))
    filetype = l[0]
    if filetype in _UNCOMPRESS_COMMAND:
        command = _UNCOMPRESS_COMMAND[filetype]
    return command


def normalize_name(name):
    return re.sub(_VALID_CHARS, _REPLACE_CHAR, name)

def normalize_filename(name):
    if name.endswith(".tar.gz"):
        filename = name[:len(name)-len(".tar.gz")]
        fileext = ".tar.gz"
    else:
        filename, fileext = os.path.splitext(name)
    return "%s%s"%(normalize_name(filename), fileext), fileext

def create_exercise_folder_if_missing(course, exercise_name, exercise_id):
    # XXX Note: exercise_id is not used. It can be removed from params
    normal_course = normalize_name(course)
    normal_exercise_name = normalize_name(exercise_name)
    #path = "%s/%s-%s"%(normal_course, exercise_id, normal_exercise_name)
    path = "%s/%s"%(normal_course, normal_exercise_name)
    if os.path.isdir(path):
        print("# WARNING: Folder %s already exists (merged)"%path)
    else:
        os.makedirs(path)
        print("# New folder %s"%path)
        print( "$ mkdir %s"%path)
    return path


def process_student_delivery(srcfilename, folder, student_name, internal_code, given_filename):
    normal_filename, fileext = normalize_filename(given_filename)
    student_code = _STUDENT_NAME_CONVERSION.get(student_name, normalize_name(student_name))
    path = "%s/%s/%s"%(folder, student_code, internal_code)

    if os.path.isdir(path):
        print("# WARNING: Delivery for %s already extracted (no changes)"%student_code)
        return

    if os.path.isdir(srcfilename):
        print("$ cp -r %s %s"%(srcfilename, path))
        shutil.copytree(srcfilename, path)
        return

    print("$ mkdir %s"%path)
    os.makedirs(path)
    dstfilename = os.path.join(path, normal_filename)
    if os.path.isdir(srcfilename):
        shutil.copytree(srcfilename, dstfilename)
    else:
        shutil.copyfile(srcfilename, dstfilename)
    command = getCompressCommand(srcfilename)
    if not command == None:
        prevpath = os.getcwd()
        os.chdir(path)
        print( "%s/ $ %s"%(path, command%normal_filename))
        returnstatus = os.system(command%normal_filename)
        if returnstatus != 0:
            print("ERROR: issuing command %s"%(command%normal_filename))
        #os.remove(normal_filename)
        os.chdir(prevpath)
    else:
        print("Direct file: %s"%normal_filename)


def process_zip(folder, zipfilename):
    tmppath = tempfile.mkdtemp()
    with zipfile.ZipFile(zipfilename, "r") as f:
        f.extractall(tmppath)
    file_content = os.listdir(tmppath)
    for c in file_content:
        m = re.match(_SUBMISSION_TEMPL, c)
        if m:
            srcfilename = os.path.join(tmppath, c)
            student_name = m.group(1)
            internal_code = m.group(2)
            given_filename = m.group(3)
            process_student_delivery(srcfilename, folder, student_name, internal_code, given_filename)
        else:
            print("# file %s doesn't match the submission template", c)
    shutil.rmtree(tmppath)


print("Extracting Moodle exercises from this location")
lst = os.listdir('.')
for f in lst:
    m = re.match(_MOODLE_FILE_TEMPL, f)
    if m:
        course=m.group(1)
        exercise_name=m.group(2)
        exercise_id=m.group(3)
        #print("# Processing course: %s exercise_name: %s exercise_id: %s"%(course, exercise_name, exercise_id))
        folder = create_exercise_folder_if_missing(course, exercise_name, exercise_id)
        if folder:
            process_zip(folder, f)

