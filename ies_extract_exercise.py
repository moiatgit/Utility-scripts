#! /usr/bin/env python
# encoding: utf-8

# This script is taylor made for the bundles of exercises generated by
# Moodle 2.
# The script 
# TODO:
#   1. allow configuring the repository of downloaded bundles as a
#   different folder from the destination of the extracted contents
#   2. Allow for confirmation and improve warnings
#   3. some refactor would be nice! This is poor code and you now it!

import os, re
import zipfile
import tempfile, shutil
import json
import subprocess

_MOODLE_FILE_TEMPL = "(.*?)-(.*?)-(\d+)\.zip"
_SUBMISSION_TEMPL  = "(.*?)_(.*?)_assignsubmission_file_(.*)"
_VALID_CHARS       = "[^a-zA-Z0-9]+"
_REPLACE_CHAR      = "_"


# External file with mapping between expected students and its folders
# This map just eases folder naming
_EXTERNAL_CONFIGURATION_FILE = os.path.abspath("./ies_extract_params.json")
if os.path.isfile(_EXTERNAL_CONFIGURATION_FILE):
    with open(_EXTERNAL_CONFIGURATION_FILE) as f:
        _STUDENT_NAME_CONVERSION = json.loads(f.read())
else:
    _STUDENT_NAME_CONVERSION = dict()


# Commands for uncompressing files { mime-type: command }
_UNCOMPRESS_COMMAND = {
    "x-7z-compressed" : "p7zip -d '%s'",
    "gzip" : "tar xzvf '%s'",
    "x-tar" : "tar xvf '%s'",
    "x-rar" : "unrar x '%s'",
    "zip" : "jar xvf '%s'",
    "java-archive" : "jar xvf '%s'",
}

# regex to extract app type from mimetype
_MIMETYPE_EXPR='^.* application\\/(.*);.*$'

def getCompressCommand(path):
    """ returns the command to be issued for uncompressing the file.
    If the filetype is unknown, none is return instead """
    mimetype = subprocess.Popen("/usr/bin/file --mime '%s'"%path, shell=True, stdout=subprocess.PIPE).communicate()[0]
    l = re.findall(_MIMETYPE_EXPR, mimetype)
    command = None
    if len(l) < 1:
        return None
    if len(l) > 1:
        print "WARNING: more than one type for file %s (%s)"%(path, l)
    filetype = l[0]
    if filetype in _UNCOMPRESS_COMMAND:
        command = _UNCOMPRESS_COMMAND[filetype]
    return command


def normalize_name(name):
    return re.sub(_VALID_CHARS, _REPLACE_CHAR, name)

def normalize_filename(name):
    if name.endswith(".tar.gz"):
        filename = name[:len(name)-len(".tar.gz")]
        fileext = ".tar.gz"
    else:
        filename, fileext = os.path.splitext(name)
    return "%s%s"%(normalize_name(filename), fileext), fileext

def create_exercise_folder_if_missing(course, exercise_name, exercise_id):
    normal_course = normalize_name(course)
    normal_exercise_name = normalize_name(exercise_name)
    path = "%s/%s-%s"%(normal_course, exercise_id, normal_exercise_name)
    if not os.path.isdir(path):
        os.makedirs(path)
        print "$ mkdir %s"%path
    return path

def create_submission_folder_if_missing(srcfilename, folder, student_name, internal_code, given_filename):
    normal_student_name = normalize_name(student_name)
    normal_filename, fileext = normalize_filename(given_filename)
    student_code = _STUDENT_NAME_CONVERSION.get(normal_student_name, normal_student_name)
    path = "%s/%s/%s"%(folder, student_code, internal_code)
    if os.path.isdir(path):
        # print "already extracted %s"%path
        pass
    else:
        print "$ mkdir %s"%path
        os.makedirs(path)
        dstfilename = os.path.join(path, normal_filename)
        shutil.copyfile(srcfilename, dstfilename)
        command = getCompressCommand(srcfilename)
        if not command == None:
            prevpath = os.getcwd()
            os.chdir(path)
            print "%s/ $ %s"%(path, command%normal_filename)
            returnstatus = os.system(command%normal_filename)
            if returnstatus <> 0:
                print "ERROR: issuing command %s"%(command%normal_filename)
            #os.remove(normal_filename)
            os.chdir(prevpath)
        else:
            print "Direct file: %s"%normal_filename


def process_zip(folder, zipfilename):
    tmppath = tempfile.mkdtemp()
    with zipfile.ZipFile(zipfilename, "r") as f:
        f.extractall(tmppath)
    file_content = os.listdir(tmppath)
    for c in file_content:
        m = re.match(_SUBMISSION_TEMPL, c)
        if m:
            create_submission_folder_if_missing(os.path.join(tmppath, c), folder, m.group(1), m.group(2), m.group(3))
        else:
            print "XXX NO ", c
    shutil.rmtree(tmppath)


print "Extracting Moodle exercises from this location"
lst = os.listdir('.')
for f in lst:
    m = re.match(_MOODLE_FILE_TEMPL, f)
    if m:
        folder = create_exercise_folder_if_missing(m.group(1), m.group(2), m.group(3))
        process_zip(folder, f)

