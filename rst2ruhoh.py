#! /usr/bin/env python
# encoding: utf-8

# This script takes a .rst file as first argument and converts it to a
# markdown with the same name and extension .md prepared for being
# used at ruhoh blogs

# required: docutils

# Generalities:
# - source files are expected in rst (ReStructuredText) format
# - every rst file belongs to a collection.
# - the collection of a file is the name of the folder containing it
# - the collection structure is replicated on ruhoh destination
# - collection usually coincides with the meta information
#   'categories' but it is not a requirement.
# - permalink is always generated by this script to allow file
#   referencing. i.e. an rst referencing another rst.

# You might want to allow completion for this script. Put the
# following code somewhere accessible by your .bashrc or source it

#   _rst2ruhoh()
#   {
#       local cur
#       COMPREPLY=()
#       _get_comp_words_by_ref cur
#
#       _filedir rst
#   }
#   complete -o default -o nospace -F _rst2ruhoh  rst2ruhoh.py

# TODO:
# - current RST2RuhohTranslator class is pretty silly. Main methods'
#   responsibilities are assigned almost randomly
# - current testing is way too manual, althoug there're an small
#   number of functions displaying some sort of doctest, there's a lot
#   of room for improvement here. I'm positive that current code
#   coverage is too low
# - naming is poor. Too much different conventions applied

#
import os, shutil, sys, re, datetime
from BeautifulSoup import BeautifulSoup, Comment
from docutils.core import publish_cmdline, default_description
from ConfigParser import ConfigParser
import argparse
import tempfile
import urllib, urlparse
#

_CONF_FILENAME = os.path.expanduser("~/.rst2ruhoh")  # configuration filename

_SPECIAL_CHAR = {   # map for special character conversion
        ord(u'à'):u'a',
        ord(u'á'):u'a',
        ord(u'è'):u'e',
        ord(u'é'):u'e',
        ord(u'í'):u'i',
        ord(u'ï'):u'i',
        ord(u'ò'):u'o',
        ord(u'ó'):u'o',
        ord(u'ú'):u'u',
        ord(u'ü'):u'u',
        ord(u'ç'):u's',
        ord(u'ñ'):u'ny',
        ord(u'('):u'_',
        ord(u')'):None,
        ord(u'·'):None,
        ord(u' '):None
        }
#
class RST2RuhohTranslator:

    def __init__(self, htmlPath, ruhohPath, rstPath, isDraft):
        self.htmlPath  = htmlPath
        self.ruhohPath = ruhohPath
        self.rstPath   = os.path.realpath(rstPath)
        self.isDraft   = isDraft
        self.meta      = {} # includes the meta information of the file
        self.collection = getCollectionFromPath(self.rstPath)
        self.dest_path = composePostDestinationPath(self.ruhohPath)
        self.path_media = composeMediaDestinationPath(self.ruhohPath)

    def translate(self):
        """ performs the translation from rst to ruhoh format. """
        self.setSoupFromHtml()
        self.setMetaInfo()
        self.setTitle()
        self.setCategories()
        self.setPermalink()
        self.setPostDate()
        self.setDraftOption()
        self.fixResourcePaths()

    def saveTranslation(self):
        """ saves the translation in the corresponding destination """
        destdir = os.path.join(self.dest_path, self.collection)
        createPathIfMissing(destdir)
        md_filename = composeMDFilename(self.dest_path, self.collection, self.rstPath)
        self.writeResultsOnFile(md_filename)

    def setTitle(self):
        """ (RST2RuhohTranslator) -> NoneType

        Sets the title of the post.  If there's no meta information
        for title, it includes this title as the meta title. 
        """
        title = self.extractTitle()
        if not title:
            title = 'untitled'
        self.addMetaIfMissing('title', title)
        self.title = title

    def addMetaIfMissing(self, tag, val):
        """ adds new tag to meta with val if tag was not already there """
        self.meta[tag] = self.meta.get(tag, val)

    def setPostDate(self):
        """ sets current date as post date if no date is expecified """
        currentDate = "'%s'"%datetime.date.today().strftime("%Y-%m-%d")
        self.addMetaIfMissing('date',currentDate)

    def setDraftOption(self):
        """ sets the draft option if isDraft and draft option is not
            already present """
        if self.isDraft:
            self.addMetaIfMissing('type', 'draft')

    def fixResourcePaths(self):
        """ fixes paths of different resources """
        src_path = os.path.dirname(self.rstPath)
        self.fixImagePaths(src_path)
        self.fixRefPaths(src_path)

    def fixImagePaths(self, path):
        """ fixes paths of images in the post from given path"""
        for img in self.soup.findAll("img"):
            img_path = os.path.join(path, img["src"])
            if os.path.exists(img_path):
                name = os.path.basename(img_path)
                collection = getCollectionFromPath(img_path)
                destdir = os.path.join(self.path_media, collection)
                createPathIfMissing(destdir)
                imgdest = os.path.join(destdir, name)
                shutil.copy(img_path, imgdest)
                img["src"]="{{urls.media}}/%s/%s"%(collection, name)
            else:
                print >> sys.stderr, "WARNING: file %s not found but linked"%img["src"]

    def fixRefPaths(self, path):
        """ fixes paths of references to other posts from given path """
        for a in self.soup.findAll("a"):
            if a.has_key("href"):
                a["href"] = self.fixHRefPath(path, a["href"])

    def fixHRefPath(self, path, href):
        """ fixes href in the following way:
            1. if href is internal, no modifications
            2. if href points to an rst file, it tries to convert
            the link to its corresponding md file.
            3. if href points to an existing file, it copies the file
            to the {{urls.media}}/:collection/ folder and fixes
            consequently the path. Attention: in case the resource
            already exists it will be overriden without considering if
            they are differents nor if there are other md pointing at it.
            4. if href points to a non existing file within the
            filesystem, it issues a warning.
            5. if href points to an external file (e.g. http://) it
            keeps the link without changes.
        """
        if href.startswith("#"):
            return href

        if isExternalResource(href):
            return href

        fileref = os.path.join(path, href)
        if not os.path.exists(fileref):
            # href points to a non existing file within the filesystem:
            print >> sys.stderr, "WARNING: missing linked file %s"%href
            return "#"

        if href.endswith('.rst'):
            return self.convertRefToCorrespondingMD(fileref)

        # it is a reference to an existing resource
        return self.fixExistingResource(fileref)

    def convertRefToCorrespondingMD(self, fileref):
        """ (RST2RuhohTranslator, str) -> str

        Given an existing rst file, it finds out the corresponding
        permalink associated to this file.
        """
        filename = os.path.basename(fileref)
        collection = getCollectionFromPath(fileref)
        mdpath = composeMDFilename(self.dest_path, collection, filename)
        permalink = extractPermalinkFromMD(mdpath)
        return permalink


    def fixExistingResource(self, fileref):
        """ fixes the path of an existing resource and returns it """
        name = os.path.basename(fileref)
        collection = getCollectionFromPath(fileref)
        destdir = os.path.join(self.path_media, collection)
        createPathIfMissing(destdir)
        filedest = os.path.join(destdir, name)
        shutil.copy(fileref, filedest)
        url = "{{urls.media}}/%s/%s"%(collection, name)
        return url

    def setSoupFromHtml(self):
        """ sets soup from the html file """
        self.soup = getContentSoupFromFile(self.htmlPath)

    def setMetaInfo(self):
        """ processes all meta information included in soup and 
        includes it in the meta property """
        getComments = lambda text:isinstance(text, Comment)
        for comment in self.soup.findAll(text=getComments):
            c = str(comment).lstrip("<!--").rstrip("-->").strip()
            m = re.match("(\w+):(.+)", c)
            if m:  # is a setting
                metaItem  = m.group(1)
                metaValue = m.group(2).strip()
                self.meta[metaItem]=metaValue
                comment.extract()

    def writeResultsOnFile(self, md_filename):
        """ write translation results on md_filename """
        md = open(md_filename, "w")
        md.write("---\n")
        for metaItem, metaVal in self.meta.iteritems():
            md.write("%s: %s\n"%(metaItem, metaVal))
        md.write("---\n\n")
        md.write(str(self.soup))
        md.close()

    def extractTitle(self):
        """ removes title from soup and returns it.
            It returns empty string when no title is found.
        """

        title = ""  # just in case of error
        titleTag = getTitleItemFromSoup(self.soup)
        if titleTag:
            title = getTitleTextFromTag(titleTag)
            titleTag.extract()
        if title == "":
            print >> sys.stderr, "WARNING: no title found in %s"%self.rstPath
            title = "untitled"
        return title


    def setCategories(self):
        """ (RST2RuhohTranslator) -> NoneType

        If categories is not present in meta, this function sets the
        collection of the rst file as the value for categories.
        """
        self.addMetaIfMissing('categories', self.collection)

    def setPermalink(self):
        """ (RST2RuhohTranslator) -> NoneType

        Creates the post permalink composed from title.

        (for back compatibility issues) if permalink is already
        specified at meta, this function issues a warning and ignores
        it.
        """
        if self.meta.has_key('permalink'):
            print >> sys.stderr, "WARNING: permalink information ignored at file %s"%self.rstPath

        permalink = composePermalink(self.collection, self.title)
        self.meta['permalink'] = permalink

####

def createPathIfMissing(path):
    """ create a directory if it doesn't already exists """
    if not os.path.exists(path):
        os.mkdir(path)

def getContentSoupFromFile(path):
    """ (str) -> BeautifulSoup

    It opens an existing file and returns the contents
    of the file as a BeautifulSoup
    """
    html = open(path).read()
    soup = BeautifulSoup(html)
    return soup.body.contents[1]    # cleaned up to body



def isExternalResource(resource):
    """ (str) -> bool

    Returns true if the resource corresponds to an external resource.

    It is considered an external resource if one of the following:
    1. "http[s]://"
    2. "ftp[s]"://"

    """
    return re.match("^(http)|(ftp)s?://", resource) <> None

def composePostDestinationPath(basepath):
    """ (str) -> str

    composes and returns the destination path of the post
    """
    return os.path.join(basepath, 'posts')

def composeMediaDestinationPath(basepath):
    """ (str) -> str

    composes and returns the destination path of the media
    """
    return os.path.join(basepath, 'media')

def getCollectionFromPath(path):
    """ (str) -> str

    It returns the collection of the file at the given path.
    >>> getCollectionFromPath('../colname/filename')
    colname
    """
    collection = os.path.basename(os.path.dirname(os.path.realpath(path)))
    return collection

def composeMDFilename(basePath, collection, rstFilename):
    """ (str, str, str) -> str

    composes the name of the markdown file from the base path,
    the collection and the rst file name"""
    name, _ = os.path.splitext(os.path.basename(rstFilename))
    mdpath = os.path.join(basePath, collection, "%s.md"%name)
    return mdpath

def extractPermalinkFromMD(mdpath):
    """ extracts and returns permalink information from the
    given md path. It returns '#' string when md file doesn't
    exists or permalink info is not present. """
    permalink = "#"
    if os.path.exists(mdpath):
        fd = open(mdpath)
        for lin in fd:
            m = re.match("^permalink: '(.*)'", lin)
            if m:
                permalink = m.group(1).strip()
                break
        else:
            print >> sys.stderr, "WARNING: file %s contains no permalink information"%mdpath
        fd.close()
    else:
        print >> sys.stderr, "WARNING: file %s not found but expected"%mdpath
    return permalink



def getTitleItemFromSoup(soup):
    """ (BeautifulSoup) -> BeautifulSoup.Tag

    It finds and returns the title of the soup. It considers the 
    title of the soup as the contents within the first <h1> tag.
    """
    return soup.find("h1")

def getTitleTextFromTag(tag):
    """ (BeautifulSoup.Tag) -> str

    It returns the text in unicode of a tag.
    """
    if tag and tag.has_key("class"):
        title = tag.text.encode('utf-8')
    else:
        title = 'untitled'
    return title


def composePermalink(collection, title):
    """ fixes the given original permalink by:
        1. granting it enclosed in quotations '
        2. granting it include collection
        3. in case original is empty, uses a normalized title
        collection and title must be nonempty strings
    """
    link = composePermalinkFromTitle(title)
    permalink = composePermalinkFromCollectionAndName(collection, link)
    return permalink


def composePermalinkFromCollectionAndName(collection, name):
    """ composes and returns the permalink from the given collection
    and name. Result will be single-quoted.
    >>> composePermalinkFromCollectionAndName('cat','nam')
    "'/cat/nam'"
    """
    return "'/%s/%s'"%(collection, name)

def composePermalinkFromTitle(title):
    """ (str) -> str

    It composes a permalink from the title of a post.
    It begins replacing special characters and then fixes it to be a
    proper url.
    """
    convert = replaceSpecialChar(title)
    urlsafe = url_fix(convert)
    return urlsafe


def replaceSpecialChar(text):
    """ (str) -> str

    Replaces special characters from a text.  It replaces each special
    character in _SPECIAL_CHAR keys by its corresponding ascii.
    """
    return text.lower()                  \
               .decode('utf8')           \
               .translate(_SPECIAL_CHAR) \
               .encode('ascii', 'ignore')

def url_fix(s, charset='utf-8'):
    """Sometimes you get an URL by a user that just isn't a real
    URL because it contains unsafe characters like ' ' and so on.  This
    function can fix some of the problems in a similar way browsers
    handle data entered by the user

    Found at https://github.com/mitsuhiko/werkzeug/blob/master/werkzeug/urls.py

    >>> url_fix(u'http://de.wikipedia.org/wiki/Elf (Begriffsklärung)')
    'http://de.wikipedia.org/wiki/Elf%20%28Begriffskl%C3%A4rung%29'

    :param charset: The target charset for the URL if the url was
                    given as unicode string.
    """
    if isinstance(s, unicode):
        s = s.encode(charset, 'ignore')
    scheme, netloc, path, qs, anchor = urlparse.urlsplit(s)
    path = urllib.quote(path, '/%')
    qs = urllib.quote_plus(qs, ':&=')
    return urlparse.urlunsplit((scheme, netloc, path, qs, anchor))

def setLocale():
    """ tries to set locale """
    try:
        import locale
        locale.setlocale(locale.LC_ALL, '')
    except:
        pass

def checkParams():
    """ checks that the arguments of the program call, and the
    configuration file are as expected. 
    In case something's wrong, an error missage is issued and 
    finishes execution with an error code.
    When everything is ok, it returns the configuration information
    in a tuple: rstPath, ruhohPath """
    p = argparse.ArgumentParser(description="Converts from rst to ruhoh format", version="1.0")
    p.add_argument('paths', metavar='path', nargs='+', help="Source file path with .rst extension")
    p.add_argument("-d", "--draft", action="store_true", help="Mark converted file as draft", dest="draft")
    p.add_argument("-r", "--ruhohPath", action="store", help="Path to ruhoh local copy. Overrides config file specs.", dest="ruhohPath")
    options = p.parse_args()
    #
    sourcelist = options.paths
    #
    for source in sourcelist:
        path, ext = os.path.splitext(source)
        if ext != ".rst":
            print >> sys.stderr, "Error: .rst extension expected in %s"%source
            sys.exit(2)
        #
        if not os.path.exists(source):
            print >> sys.stderr, "Error: file not found: %s"%source
            sys.exit(4)
    #
    if options.ruhohPath:
        ruhohPath = options.ruhohPath
    else:
        # check configuration file
        c = ConfigParser()
        try:
            c.read(_CONF_FILENAME)
            ruhohPath = os.path.expanduser(c.get('RUHOH', 'local_path'))
        except:
            print >> sys.stderr, "Error: %s expected with contents\n"%_CONF_FILENAME +\
                    "[RUHOH]\n" +\
                    "local_path = path/to/ruhoh/local/site"
            sys.exit(3)
    #
    if not os.path.exists(ruhohPath):
        print >> sys.stderr, "Error: file not found: %s"%ruhohPath
        sys.exit(5)
    #
    isDraft = options.draft
    #
    return sourcelist, ruhohPath, isDraft

def main():

    # try to set locale
    setLocale()

    # get configuration information
    sourcelist, ruhohPath, isDraft = checkParams()

    for rstPath in sourcelist:
        # prepare params for docutils
        sys.argv = [sys.argv[0], rstPath]

        # define html output filename for docutils
        html_file = tempfile.NamedTemporaryFile()
        htmlPath = html_file.name
        sys.argv.append(htmlPath)

        # generate html conversion
        description = ('Generates ruhoh\'s md documents from standalone '
                       'reStructuredText sources.  ' + default_description)
        publish_cmdline(writer_name='html', description=description)

        # create md for ruhoh
        translator = RST2RuhohTranslator(htmlPath, ruhohPath, rstPath, isDraft)
        translator.translate()
        translator.saveTranslation()
        #
    return 0
#
if __name__=="__main__":
    sys.exit(main())

